package Middle.递增的三元子序列;public class IncreasingTripletSubsequence {    public boolean increasingTriplet(int[] nums) {        // 贪心        int n = nums.length;        if (n<3) return false;        int first = nums[0], second = Integer.MAX_VALUE;        for (int i=1; i<n; i++){            if (nums[i]>second){  // 出现第三小的数据，连成三元子序列                return true;            }else if (nums[i]>first){                second = nums[i];  // 出现第二小的数据            }else {                first = nums[i];  // 出现更小的数字，后面的机会会更大，更新第一小数据            }        }        return false;    }    // 双向遍历    // 两个数组，一个数组存从左侧开始的最小值，另一个存从右侧开始的最大值    // 然后再次遍历整个数组，判断当前数字是否在两个数组的最大值和最小值之间    // 从而形成三元子序列    public boolean increasingTriplet2(int[] nums){        int n = nums.length;        if (n<3) return false;        int[] leftMin = new int[n];        int[] rightMax = new int[n];        leftMin[0] = nums[0];        for (int i=1; i<n; i++){            leftMin[i] = Math.min(nums[i], leftMin[i-1]);        }        rightMax[n-1] = nums[n-1];        for (int i=n-2; i>=0; i--){            rightMax[i] = Math.max(nums[i], rightMax[i+1]);        }        for (int i=1; i<n-1; i++){            if (nums[i]>leftMin[i] && nums[i]<rightMax[i]) return true;        }        return false;    }}