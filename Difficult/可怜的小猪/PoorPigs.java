package Difficult.可怜的小猪;public class PoorPigs {    /**     * 有buckets桶水，然后用小猪判断哪桶水有毒，小猪可以依次喝任意多的水，在一定时间后会发生作用，有毒的小猪死去     * @param buckets           水的桶数     * @param minutesToDie      小猪喝完水后的观察时间     * @param minutesToTest     我们可以使用的总时间     * @return                  返回规定时间内判断出哪一桶有毒所需要的小猪的最少数量     *     * 微扰理论的进制论思想：那假设我们可以做两轮实验呢？     * 每只猪可能会在第0轮死亡，第1轮死亡，第2轮死亡；这样一只猪可以获得一个3进制bit所能表示的信息。     * 而我们最重要获得的信息是n个桶里面的某一个桶有哪一个是有毒的，一共有n个情况。     * 写成3进制，需要log_3(n)log_3(n)位；也就是需要log_3(n)log_3(n)只猪猪。     * 可以看图：进制论     */    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {        int iterations = minutesToTest/minutesToDie;  // 总共会进行多少轮        if (iterations<1 || buckets<2) // 一轮都进行不了，这只有一桶水            return 0;        /*            对于it轮验证，一只猪可以验证it+1桶水。假设进行4轮，如下：            1. 喝(0)号，有毒，无毒继续            2. 喝(1)号，有毒，无毒继续            3. 喝(2)号，有毒，无毒继续            4. 喝(3)号，有毒，无毒继续            5. 不和，由上面无毒知道，这里有毒            如果两只猪同时喝，可以喝 pow(base, 2) 桶水，也就是25桶水，可以看截图            那么对于n只猪同时喝，可以喝 pow(base, n) 桶水，在判断出一桶水有毒后，就会用掉n只猪            我们只需要判断 base^n >= buckets 的时候，n 等于多少            换句话说： n>=log(buckets)/log(base)            注意：base=it+1         */        return (int) Math.ceil(Math.log(buckets)/Math.log(iterations+1));    }    /*        官解 —— 动态规划：https://leetcode-cn.com/problems/poor-pigs/solution/ke-lian-de-xiao-zhu-by-leetcode-solution-z0h7/        f(i,j) = sum(f(k,j-1)*C(i,k))  k=0...i        C(i,k)表示i个数字选k个，组合数。C(i,k) = C(i-1,j-1)+C(i-1,j)        f(i,j)表示i只猪测试j轮最多可以在多少桶液体中确定有毒的是哪一桶     */    public int poorPigsDP(int buckets, int minutesToDie, int minutesToTest) {        if (buckets == 1) {            return 0;        }        int[][] combinations = new int[buckets + 1][buckets + 1];        combinations[0][0] = 1;        int iterations = minutesToTest / minutesToDie;        int[][] f = new int[buckets][iterations + 1];        for (int i = 0; i < buckets; i++) {            f[i][0] = 1;        }        for (int j = 0; j <= iterations; j++) {            f[0][j] = 1;        }        for (int i = 1; i < buckets; i++) {            combinations[i][0] = 1;            combinations[i][i] = 1;            for (int j = 1; j < i; j++) {                combinations[i][j] = combinations[i - 1][j - 1] + combinations[i - 1][j];            }            for (int j = 1; j <= iterations; j++) {                for (int k = 0; k <= i; k++) {                    f[i][j] += f[k][j - 1] * combinations[i][i - k];                }            }            if (f[i][iterations] >= buckets) {                return i;            }        }        return 0;    }}