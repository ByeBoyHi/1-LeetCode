package Difficult.得分最高的最小轮调;import java.util.Arrays;public class BestRotation {    /*        差分算法的思想：            diffs[i] = sum[i]-sum[i-1];            也即是说diffs[i]表示的是在i位置合理的个体。     */    public int bestRotation(int[] nums) {        int n = nums.length;        int[] diffs = new int[n];        for (int k = 0; k < n; k++) {  // 依次进行k轮换            int low = (k + 1) % n;            int high = (k - nums[k] + n + 1) % n;            diffs[low]++;  // 必然合理位            diffs[high]--; // 必然不合理位            // 当合理位和不合理位交错而过的时候            // 说明这个位置的值只有0轮换是合理的            if (low >= high) {                diffs[0]++;            }        }        // 上面的计算是有正有负的，需要用变量来记录分数的变化        int minIndex = 0;        int maxScore = 0;        int score = 0;        for (int i = 0; i < n; i++) {            score += diffs[i];            if (score>maxScore){                maxScore = score;                minIndex = i;            }        }        return minIndex;    }}