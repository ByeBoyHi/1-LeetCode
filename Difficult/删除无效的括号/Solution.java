package Difficult.删除无效的括号;import java.util.*;/** * "()()()))((()(()()" * ["((()))()()()","((()))()(())","((()))(())()","((()))(()())","((()))((()))","(()())()()()", * "(()())()(())","(()())(())()","(()())(()())","(()())((()))","()(())()()()","()(())()(())", * "()(())(())()","()(())(()())","()(())((()))","()()()()()()","()()()()(())","()()()(())()", * "()()()(()())","()()()((()))"] */public class Solution {    public static void main(String[] args) {        System.out.println(new Solution().removeInvalidParentheses("((())()(()))"));    }    private List<String> setRight = new ArrayList<>(); // 去重处理右括号    private List<String> setLeft = new ArrayList<>();  // 去重处理左括号    public List<String> removeInvalidParentheses(String s) {        int[] arr = getInfo(s);        String left = s.substring(0, arr[2]+1);        String right = s.substring(arr[2]+1);        dfs(left, arr[0], 0, 0, 1);        dfs(right, arr[1], 0, arr[2]+1, 0);        List<String> ans = new ArrayList<>();        for (int i=0; i<setLeft.size(); i++){            for (int j=0; j<setRight.size(); j++){                ans.add(setRight.get(j)+setLeft.get(i));            }        }        return ans;    }    /**     * 递归生成左侧有效括号     *     * @param s      需要遍历的括号字符串     * @param num    多余的右括号的个数     * @param cur    当前已经删除了多少个多余小括号了     * @param start  本次递归应该从第几个位置开始判断右括号     * @param flag   判断本次dfs是要解决多余右括号还是多余左括号     */    private void dfs(String s, int num, int cur, int start, int flag) {        if (s.length()-start<num-cur) return;  // 如果剩下需要判断的长度已经小于我们需要删除的多余右括号的最低需求，直接退出        if (cur == num && isValid(s)) {  // 已经删除了指定数量的右括号，并且当前字符串是有效括号            if (flag==1 && !setRight.contains(s)) {                setRight.add(s);            }else {                if (!setLeft.contains(s))                    setLeft.add(s);            }            return;        }        if (start==s.length()) return;        StringBuilder sb = new StringBuilder(s);        for (int i = start; i < s.length(); i++) {            switch (flag){  // 用来控制处理左括号还是右括号。                case 1:                    if (s.charAt(i) == ')') { // 如果是右括号，有两种可能，删除或者保留                        // 删除                        sb.deleteCharAt(i);                        dfs(sb.toString(), num, cur + 1, start, flag);                        // 保留                        sb.insert(i, ')');                        dfs(sb.toString(), num, cur, start + 1, flag);                    }                    break;                case 0:                    if (s.charAt(i)=='('){                        // 删除                        sb.deleteCharAt(i);                        dfs(sb.toString(), num, cur + 1, start, flag);                        // 保留                        sb.insert(i, '(');                        dfs(sb.toString(), num, cur, start + 1, flag);                    }                    break;            }        }    }    private int[] getInfo(String s) {        // arr[0] 左边多余的右括号的个数        // arr[1] 右边多余的左括号的个数        // arr[2] 多余的左右括号的分界点，当前点及左边是多余的右括号，右边是多余的左括号        // arr[3] 左边有效右括号的总个数        // arr[4] 右边有效左括号的总个数        int[] arr = new int[5];        Stack<Character> stack = new Stack<>();        for (int i = 0; i < s.length(); i++) {            if (s.charAt(i) == ')') {                while (!stack.isEmpty() && stack.peek() != '(') {                    stack.pop();                }                if (stack.isEmpty()) {  // 无效的右括号个数                    arr[0]++;                    if (i != arr[2] + 1) {                        arr[3] += ((i - arr[2]) >> 1);                    }                    arr[2] = i; // 不断更新多余的右括号的位置，取最右侧的。                } else {  // 左边有效的有括号个数                    // 右括号为0就是还没有遇到多余的右括号                    if (arr[2] == 0) {                        arr[3]++;                    }                }            } else { // 左括号或者其他字符                stack.push(s.charAt(i));            }        }        // index以及index左边是右括号多余的，右边则是左括号多余的区域。        arr[1] = stack.size();        arr[4] = (s.length() - 1 - arr[2] - arr[1]) >> 1;        return arr;    }    // 判断是否是有效括号    private boolean isValid(String s) {        int cnt = 0;        for (int i=0; i<s.length(); i++){            if (s.charAt(i)=='('){                cnt++;            }else if (s.charAt(i)==')'){                if (cnt==0){                    return false;                }                cnt--;            }        }        return cnt==0;    }}