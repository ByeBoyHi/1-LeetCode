package Difficult.完美矩阵;import java.util.*;public class Solution {    /**     * 我的思路：     * 所有矩阵的面积之和是否等于最大那个矩阵的面积之和即可     * 1. 用一个类对象line进行存储横轴和纵轴的起点终点，用来判断是否能形成矩形     * 2. 计算所有矩形面积和以及矩阵的面积，判断是否相等     */    /**     * 宫水三叶的解题思路：     * 对于一个矩阵，是由很多个小矩阵构成的，除了两端的边只出现了一次，里面的每一条整边都出现了两次     * 1. 用一个2n的数组，存储里面每一个矩阵的左右两个边，左边的记录正，右边的记录负     * 2. 用一个坐标x进行边的分开，在同一个x上，左右两类边是同长的     * 3. 记录一个矩阵的y1和y2，用于这条直线上的正向线的拼接和负向线的拼接     * 4. 用两个列表ArrayList来存储每一次遇到的正向线和反向线，用于判断正向线和反向线是否成对出现且起点终点一样     * 5. 对于2n的数组，里面每一个小元素的内容是：{x, y1, y2, 1/-1}：左边的用1，右边的用-1     */    public boolean isRectangleCover(int[][] rectangles) {        int n = rectangles.length;        int[][] rs = new int[2 * n][4];        int idx = 0;  // 用来移动rs的存储位置        for (int[] rec : rectangles) {  // 存储完毕            rs[idx++] = new int[]{rec[0], rec[1], rec[3], 1};            rs[idx++] = new int[]{rec[2], rec[1], rec[3], -1};        }        Arrays.sort(rs, (a, b) -> {  // 先根据x排序，x一样的话，按照y1从低到高排序，这样同一个x的不同点就挨在一起了，并且是从低到高的顺序            if (a[0] != b[0]) return a[0] - b[0];            return a[1] - b[1];        });        List<int[]> l1 = new ArrayList<>();  // 存储左向        List<int[]> l2 = new ArrayList<>();  // 存储右向        n = n * 2;  // 下面要开始遍历整个rs表，所以长度需要double一下        for (int l = 0; l < n; ) {            int r = l;  // 记录当前的数组值            // 清理掉l1 和 l2上一轮剩下的点集            l1.clear();            l2.clear();            // 不断的往后找，把同一根线的所有线段数组都找到            while (r < n && rs[r][0] == rs[l][0]) r++;  // 只要目前是同一个线上的，我们就不断往后走，直到遇到了不是同一直线的            for (int i = l; i < r; i++) {                int[] cur = new int[]{rs[i][1], rs[i][2]};                List<int[]> list = rs[i][3] == 1 ? l1 : l2;                if (list.isEmpty()) {  // 如果是空的，直接添加进去                    list.add(cur);                } else {// 如果不是空的                    // 取出当前列表的最后一个元素，因为最后一个元素是我们拼接的最后                    int[] prev = list.get(list.size() - 1);  // 这时候prev和list最后一个元素是同一个地址，这是引用传递                    // 如果交叉                    if (prev[1] > cur[0]) return false;                    // 首尾相连                    if (prev[1] == cur[0]) prev[1] = cur[1];                    else list.add(cur);                }            }            // 在x点的所有值都添加到l1和l2上面之后            // 如果是两端的点，则有l=0或者r=n            if (l == 0 || r == n) {                if (l1.size() + l2.size() != 1) return false;  // 因为两端只有一条边，没有成对出现，所以之和必然是1            } else {                // 判断是否成对出现                if (l1.size() != l2.size()) return false;                // 左右是否完美衔接                for (int i = 0; i < l1.size(); i++) {                    if (l1.get(i)[0] == l2.get(i)[0] && l1.get(i)[1] == l2.get(i)[1]) continue;                    return false;                }            }            // 进入下一个x点            l = r;        }        return true;    }    /**     * 14ms大佬思路：     * 1. 首先一个合理的矩阵，是没有交集的，且最后的矩阵周围是四四方方的。     * 2. 即矩阵上面所有的点，都只有矩阵四周的四个点出现了一次，内部的所有点都出现了偶数次     * 3. 我们可以对里面的点进行记录，只要出现一次，就添加进去，如果出现了第二次，就删掉     * 4. 即每次出现一个点，都判断在集合里面是否存在，如果不存在，那么加进去，如果存在，那么删掉集合里面对应的点，因为是重复点     * 5. 并且在这个遍历点的过程中，我们需要取找最小的x和y，以及最大的x和y，组合成矩阵的四个角     */    public boolean isRectangleCover2(int[][] rectangles) {        int x = Integer.MAX_VALUE;        int y = Integer.MAX_VALUE;        int a = Integer.MIN_VALUE;        int b = Integer.MIN_VALUE;        int area = 0;        int _area = 0;        Set<Integer> set = new HashSet<>();        for (int[] rec : rectangles) {            // 取当前矩阵的左下角和右上角的点            int x1 = rec[0];            int y1 = rec[1];            int x2 = rec[2];            int y2 = rec[3];            // 存储记录当前小矩阵的面积            area += (x2 - x1) * (y2 - y1);            // 只要有一个在降低，就减小，不断的往最小值靠近，因为如果不缺角，那么另一个也会减小到合适的位置，如果缺角，就会有一个变小了，但是另一个变大的情况出现            if (x1 < x || y1 < y) {                x = x1;                y = y1;            }            if (x2 > a || y2 > b) {                a = x2;                b = y2;            }            // 对四个角的点进行记录            record(set, x1, y1);            record(set, x1, y2);            record(set, x2, y1);            record(set, x2, y2);        }        _area = (b - y) * (a - x);        if (area != _area) return false; // 如果里面小矩阵的面积不等于外面大矩阵的面积        // 最后循环完毕后，set里面应该只有四个点，也就是四个角        // 并且这四个点必须是矩阵的四个角，而不是别的奇怪的点        return set.size() == 4                && set.contains(key(x, y))                && set.contains(key(x, b))                && set.contains(key(a, y))                && set.contains(key(a, b));    }    // 用一个方法记录，判断set集合里面是否出现过    private void record(Set<Integer> set, int x, int y) {        int key = key(x, y);        if (set.contains(key)) {            set.remove(key);        } else {            set.add(key);        }    }    private int key(int x, int y) {        // 因为点的范围是-100000到100000        // 这里如果x接近0，但是y接近100000，就可能出现不同的点计算出同样的值        // 所以为了保证x的权重，前面就乘了100000，并且相乘相加也不会越界        return 100000 * x + y;    }}class Solution2 {    public boolean isRectangleCover(int[][] rectangles) {        long area = 0;        int minX = rectangles[0][0], minY = rectangles[0][1], maxX = rectangles[0][2], maxY = rectangles[0][3];        Map<Point, Integer> cnt = new HashMap<>();        for (int[] rect : rectangles) {            int x = rect[0], y = rect[1], a = rect[2], b = rect[3];            area += (long) (a - x) * (b - y);            minX = Math.min(minX, x);            minY = Math.min(minY, y);            maxX = Math.max(maxX, a);            maxY = Math.max(maxY, b);            Point point1 = new Point(x, y);            Point point2 = new Point(x, b);            Point point3 = new Point(a, y);            Point point4 = new Point(a, b);            // 记录所有的点出现的次数            cnt.put(point1, cnt.getOrDefault(point1, 0) + 1);            cnt.put(point2, cnt.getOrDefault(point2, 0) + 1);            cnt.put(point3, cnt.getOrDefault(point3, 0) + 1);            cnt.put(point4, cnt.getOrDefault(point4, 0) + 1);        }        // 矩形的四个角        Point pointMinMin = new Point(minX, minY);        Point pointMinMax = new Point(minX, maxY);        Point pointMaxMin = new Point(maxX, minY);        Point pointMaxMax = new Point(maxX, maxY);        // 面积不等或者有一个角不存在或者出现次数超过1次，这个矩形就无法形成或有交叉面积        // 因为矩阵的四个角是只能出现一次的        if (area != (long) (maxX - minX) * (maxY - minY) || cnt.getOrDefault(pointMinMin, 0) != 1 || cnt.getOrDefault(pointMinMax, 0) != 1 || cnt.getOrDefault(pointMaxMin, 0) != 1 || cnt.getOrDefault(pointMaxMax, 0) != 1) {            return false;        }        // 去掉四个角的点，因为四个角的出现了一次，而矩阵内部的点都是出现了至少2次，需要排除四个合理的点取判断内部的点是否合理        cnt.remove(pointMinMin);        cnt.remove(pointMinMax);        cnt.remove(pointMaxMin);        cnt.remove(pointMaxMax);        for (Map.Entry<Point, Integer> entry : cnt.entrySet()) {            int value = entry.getValue();            // 因为value是一个点出现的次数            // 同一个点只能出现2次或者4次，否则是无法完美契合的，当出现了别的次数的时候，就说明有交叉面积            if (value != 2 && value != 4) {                return false;            }        }        return true;    }}class Point {    int x;    int y;    public Point(int x, int y) {        this.x = x;        this.y = y;    }    @Override    public int hashCode() {        return x + y;    }    @Override    public boolean equals(Object obj) {        if (obj instanceof Point) {            Point point2 = (Point) obj;            return this.x == point2.x && this.y == point2.y;        }        return false;    }}