package Middle.网络空闲的时刻;import java.util.*;public class NetFreeTime {    // 空闲时间受最远机器及重发间隔影响，所以计算综合最高的即可，由近及远    public int networkBecomesIdle(int[][] edges, int[] patience) {        int n = patience.length;        List<Integer>[] adj = new ArrayList[n];        for (int i = 0; i < n; ++i) {            adj[i] = new ArrayList<>();        }        boolean[] visit = new boolean[n];        for (int[] v : edges) {            adj[v[0]].add(v[1]);            adj[v[1]].add(v[0]);        }        Queue<Integer> queue = new ArrayDeque<>();        queue.offer(0);  // 主机        visit[0] = true;        int dist = 1;        int ans = 0;        while (!queue.isEmpty()) {            int size = queue.size();            for (int i = 0; i < size; i++) {                int curr = queue.poll();                for (int v : adj[curr]) {                    if (visit[v]) {                        continue;                    }                    queue.offer(v);                    // 见tips                    /*                        两个来回就是2dist                        从第一次发送信息，到收到回复，整个时间是2dist，那么最后一秒收到信息的时候是不会再发送信息了，                        所以计算的是2dist-1之间有多少个patience，然后得到最后一次patience，从这次出发                        再经过2dist，就回收到这最后一次回复，再+1就是这个服务器的空闲时间。                     */                    int time = patience[v] * ((2 * dist - 1) / patience[v]) + 2 * dist + 1;                    ans = Math.max(ans, time);                    visit[v] = true;                }            }            dist++;        }        return ans;    }}