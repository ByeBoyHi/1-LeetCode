package Middle.验证二叉搜索树;public class Solution {    static class ReturnType {        int max;        int min;        boolean isBST;        public ReturnType(int max, int min, boolean isBST) {            this.max = max;            this.min = min;            this.isBST = isBST;        }    }    public boolean isValidBST(TreeNode root) {        return process(root).isBST;    }    public static ReturnType process(TreeNode head) {        if (head == null) {  // 空节点            return null;  // 这里不方便设置最大值和最小值，我们直接返回空        }        // 左右各生成返回类        ReturnType left = process(head.left);        ReturnType right = process(head.right);        // 二叉搜索树，右树最大，左树最小        int max = head.val;        int min = head.val;        boolean isBST = true;        /*            一个数是BST的前提：                1. 他的值大于左子树的最大值                2. 他的值小于右子树的最小值                3. 他的左右子树都是BST         */        if (right != null) {            max = right.max;            isBST = (head.val < right.min) && right.isBST;        }        if (left != null) {            min = left.min;            isBST = isBST && (head.val > left.max) && left.isBST;        }        return new ReturnType(max, min, isBST);    }}/** * 使用递归的方式解题：一个树有严格的要求，当前节点大于左子树的最大值，小于右子树的最小值 * 那么外面可以使用两个值 INF 和 -INF来代替这两个值 * 然后不断的递归树，当出现了新的MAX和MIN的时候，就不断更新 * 对于左树，根节点是最大值，对于右树，根节点是最小值 */class TreeNode {    int val;    TreeNode left;    TreeNode right;    public TreeNode(int val) {        this.val = val;    }    public TreeNode(int val, TreeNode left, TreeNode right) {        this.val = val;        this.left = left;        this.right = right;    }}class Recursion{    public boolean isValidBST(TreeNode root) {        return process(root, Long.MIN_VALUE, Long.MAX_VALUE);    }    public boolean process(TreeNode root, long lower, long upper){        if (root==null){            return true;        }        if (root.val<lower || root.val>upper){            return false;        }        // 把当前值作为左子树的最大值，右子树的最小值        return process(root.left, lower, root.val)                && process(root.right, root.val, upper);    }}