package Easy.K次取反后最大化的数组和;import java.util.Arrays;import java.util.HashMap;import java.util.Map;import java.util.PriorityQueue;public class MaximizeSumOfArrayAfterKNegations {    public int largestSumAfterKNegations(int[] nums, int k) {        PriorityQueue<Integer> pq = new PriorityQueue<>();        for (int num : nums) {            pq.add(num);        }        // 把所有负数变成正数        while (k > 0 && !pq.isEmpty()) {            int cur = pq.poll();            if (cur < 0) {                pq.add(-cur);                k--;            } else {                pq.add(cur);                break;            }        }        if (!pq.isEmpty() && k != 0) {            if ((k & 1) == 1) { // 奇数                int cur = pq.poll();                pq.add(-cur);            }        }        int sum = 0;        while (!pq.isEmpty()){            sum+=pq.poll();        }        return sum;    }    // 不用额外空间    public int largestSumAfterKNegations1(int[] nums, int k) {        int len = nums.length;        int sum = 0;        Arrays.sort(nums);        for (int i=0; i<len && nums[i]<0 && k>0; i++, k--){            nums[i] = -nums[i];        }        Arrays.sort(nums);        if (k!=0){            if ((k&1)==1){                nums[0] = -nums[0];            }        }        for (int num: nums){            sum+=num;        }        return sum;    }    // 官解哈希表    public int largestSumAfterKNegations2(int[] nums, int k) {        Map<Integer, Integer> map = new HashMap<>();        int ans = 0;        for (int num : nums) {            ans += num;            map.put(num, map.getOrDefault(num, 0) + 1);        }        for (int i=-100; i<0; i++){            if (map.containsKey(i)){                int ops = Math.min(k, map.get(i));                ans+=(-i)*ops*2;                map.put(i, map.get(i)-ops);                map.put(-i, map.getOrDefault(-i, 0)+ops);                k-=ops;                if (k==0){                    break;                }            }        }        if (k>0 && (k&1)==1 && !map.containsKey(0)){            for (int i=1; i<=100; i++){                if (map.containsKey(i) && map.get(i)!=0){                    ans-=2*i;                    break;                }            }        }        return ans;    }}