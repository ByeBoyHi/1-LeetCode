package Middle.超级次方;public class SuperPow {    final static int MOD = 1337;    /*        (a*b)mod m = (a mod m)*(b mod m) mod m        直接用公式超时了，加一个快速幂     */    public static int superPow(int a, int[] b) {        int ans = 1;        for (int i = b.length - 1; i >= 0; i--) {            // 这里算的是 (上一次的结果) * (a^b[i]) % MOD            // 比如 b[1] = 2，这个2对于整个数字来说是20次幂，有：            // (a^b[0]%MOD) * (((a^10 % MOD)^b[2]) % MOD) % MOD            ans = (int) ((long) ans * pow(a, b[i]) % MOD);            // 这里计算的是 a^10 % MOD            a = pow(a, 10);            // 这个等式用了模运算分配律的性质        }        return ans;    }    public int superPow2(int a, int[] b) {        int ans = 1;        for (int e : b) {            ans = (int) ((long) pow(ans, 10) * pow(a, e) % MOD);        }        return ans;    }    // 在算快速幂的时候求一个余数    public static int pow(int x, int n) {        int res = 1;        while (n != 0) {            if (n % 2 != 0) {                res = (int) ((long) res * x % MOD);            }            x = (int) ((long) x * x % MOD);            n /= 2;        }        return res;    }    public static void main(String[] args) {//        int a = 2147483647;//        System.out.println(a-(a/1337)*1337);        System.out.println(superPow(2147483647, new int[]{                2, 0, 0        }));        System.out.println(Integer.MAX_VALUE);        System.out.println(Integer.MIN_VALUE);    }}