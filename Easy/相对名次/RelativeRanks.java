package Easy.相对名次;import java.util.Arrays;import java.util.HashMap;import java.util.PriorityQueue;public class RelativeRanks {    // 用优先队列和哈希表暴力破解：前提是分数各不相同    public String[] findRelativeRanks(int[] score) {        int len = score.length;        String[] res = new String[len];        // 大根堆        PriorityQueue<Integer> pq = new PriorityQueue<>((o1, o2) -> o2-o1);        HashMap<Integer, Integer> map = new HashMap<>();        for (int i=0; i<len; i++){            pq.add(score[i]);            map.put(score[i], i);        }        int num = 1;        while (!pq.isEmpty()){            int index = map.get(pq.poll());            if (num==1){                res[index] = "Gold Medal";            }else if (num==2){                res[index] = "Silver Medal";            }else if (num==3){                res[index] = "Bronze Medal";            }else {                res[index] = num+"";            }            num++;        }        return res;    }    // 利用排序    public String[] findRelativeRanks2(int[] score) {        int len = score.length;        String[] ans = new String[len];        String[] desc = {"Gold Medal", "Silver Medal", "Bronze Medal"};        // 前面一个记录分数，后面记录分数的索引位置        int[][] arr = new int[len][2];        for (int i=0; i<len; i++){            arr[i][0] = score[i];            arr[i][1] = i;        }        // 根据分数降序排序，然后就可以用索引给ans赋值        Arrays.sort(arr, (a,b)->b[0]-a[0]);        for (int i=0; i<len; i++){            if (i>=3){                ans[arr[i][1]] = Integer.toString(i+1);            }else {                ans[arr[i][1]] = desc[i];            }        }        return ans;    }}