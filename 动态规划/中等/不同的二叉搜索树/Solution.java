package 动态规划.中等.不同的二叉搜索树;

public class Solution {
    /**
     * 找 n 个节点的情况下，二叉搜索树的种类有多少：左小右大的规则
     * @param n   节点个数
     * @return    二叉搜索树的个数
     * 思路：
     *      假设一个序列 1...n，那么以任意一个点 i 为根建立二叉搜索树，左子树是 1...(i-1)，右子树是 (i+1)...n
     *      设立两个函数 G(n)：序列长度为n的二叉搜索树的个数。
     *                 F(i, n)：以 i 为根的二叉搜索树的个数。
     *      那么有：G(n) = sum F(i, n)  -- i 从 1~n
     *      假设有 1 2 3 4 5 6 7，以 3 为根，左子树是 1 2，右子树是 4 5 6 7，那么有：
     *          F(3, 7) = G(2) * G(4)  // 笛卡尔积
     *      因为建立以某个点为根的树和内容无关，只和长度有关。
     *      所以有：F(i, n) = G(i-1)*G(n-i)  // 前半截长度和后半截长度，不是看下标，不是i+1
     *      则有：G(n) = sum G(i-1)*G(n-i) -- i 从 1~n
     *      初始 G(0) = G(1) = 1（0个节点和1个节点）
     */
    public int numTrees(int n) {
        int[] G = new int[n+1];
        G[0] = G[1] = 1;
        for (int i=2; i<=n; i++){  // 从有2个节点开始计算
            for (int j=1; j<=i; j++){  // 从1~n
                G[i] += G[j-1]*G[i-j];
            }
        }
        return G[n];
    }
}
