package Difficult.K个逆序对数组;

public class Solution {
    /**
     * k个逆序对
     * 假设一个数组是[1,2,3,4,5,6,7,8]
     * 现在需要"一个"逆序对，
     * 以 1 为不动点，那么只能是 2 往前一步
     * 以 2 为不动点，只能是 3 往前一步
     * ...
     * 以 i 为不动点，只能是 i+1 往前一步
     * 在有k个逆序对的时候，第n个数字不可能走到n-k之前，因为这样就会多于k个逆序对
     * 第1个数字也不能走到1+k数字的后面，因为也会多于k个逆序对
     * <p>
     * 假设f[i][j]表示 1,2,...,i的数字恰好有j个逆序对，我们取第k个数字放在最后，那么产生了i-k个逆序对。
     * 现在我们只需要在前面 1,2,..,k-1,k+1,...,i 里面产生j-(i-k)个逆序对即可。
     * 让后面的 k+1,...,n都-1得到 1,2,...,k,...,i-1，
     * 那么这时候我们就变成了从前面 i-1个取 j-(i-k)个逆序对，即f[i-1][j-(i-k)]
     * 然后对于最开始的 1,2,...,k,...,i个数字的每一位都有这个规律。
     * 那么有：f[i][j]=sum(f[i-1][j-(i-k)]) k=1..i
     * 可换算成：f[i][j]=sum(f[i-1][j-k])  k=0..(i-1)  (交换上下限)
     * 因为 f[i][j-1] = sum(f[i-1][j-k-1])  k=0..(i-1)
     * 所以 f[i][j] = f[i][j-1] + f[i-1][j] - f[i-1][j-i]  (上面 - 下面)
     * 且我们需要注意：j<0是不存在的，即为 0。初始条件 f[0][0]=1，即0个逆序对
     * <p>
     * 因为只有两个前后两个相关，所以可以优化成滚动数组
     */
    public int kInversePairs(int n, int k) {
        // 这个值类似于0x3f3f3f：是个半满的值，防止值溢出可以使用
        int MOD = 1000000007;
        // 使用n个数字生成最多k个逆序对
        int[][] dp = new int[2][k + 1];
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= k; j++) {
                int cur = i & 1, prev = cur ^ 1;
                dp[cur][j] = (j >= 1 ? dp[cur][j - 1] : 0) + dp[prev][j] - (j >= i ? dp[prev][j - i] : 0);
                if (dp[cur][j] >= MOD) {
                    dp[cur][j] -= MOD;
                } else if (dp[cur][j] < 0) {
                    dp[cur][j] += MOD;
                }
            }
        }
        return dp[n & 1][k];
    }
}
