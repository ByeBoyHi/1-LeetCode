package Daily_Topic.颠倒二进制位;

/**
 * 翻转给定的 32 位无符号整数的二进制位。
 * <p>
 * 示例 1：
 * <p>
 * 输入: 00000010100101000001111010011100
 * 输出: 00111001011110000010100101000000
 * 解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
 * 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
 * <p>
 * 示例 2：
 * <p>
 * 输入：11111111111111111111111111111101
 * 输出：10111111111111111111111111111111
 * 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
 * 因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
 */
public class Solution {
    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.reverseBits2(43261596));
    }
    // you need treat n as an unsigned value

    /**
     * 对称法构造：
     * 时间复杂度int固定32，循环次数不随样本变化而变化，O(1)
     * 空间复杂度O(1)
     *
     * @param n 输入整数
     * @return 返回颠倒整数
     */
    public int reverseBits(int n) {
        int res = 0;
        for (int i = 0; i < 32; i++) {  // 总共31次，不移位就是当前最低位，所以一共只移动判断31次
            if (((n >> i) & 1) == 1) {  // 如果第i位为1
                res = res | (1 << (31 - i));  // 将第32-i位数字转为1（对称位）（或运算）
            }
        }
        return res;
    }

    /**
     * 逐位分离构造
     * 每次都使用 nn 的最低一位，使用 n 的最低一位去更新答案的最低一位，使用完将 n 进行右移一位，将答案左移一位。
     * 时间复杂度：int 固定 32 位，循环次数不随输入样本发生改变。复杂度为 O(1)
     * 空间复杂度：O(1)
     * @param n 输入整数
     * @return 返回颠倒整数
     */
    public int reverseBits2(int n) {
        int res = 0;
        int cur = 31;
        while (cur-- > 0) {  // 31-1 总共31次
            res += (n & 1);
            n >>= 1;
            res <<= 1;
        }
        return res;
    }

    /**
     * 分组互换 构造
     * 两位互换 -> 四位互换 -> 八位互换 -> 十六位互换
     * 时间复杂度：如何进行互换操作取决于 int 长度。复杂度为 O(1)
     * 空间复杂度：O(1)
     * @param n 输入整数
     * @return  返回颠倒整数
     */
    public int reverseBits3(int n) {
        n = ((n & 0xAAAAAAAA) >>> 1)  | ((n & 0x55555555) << 1);
        n = ((n & 0xCCCCCCCC) >>> 2)  | ((n & 0x33333333) << 2);
        n = ((n & 0xF0F0F0F0) >>> 4)  | ((n & 0x0F0F0F0F) << 4);
        n = ((n & 0xFF00FF00) >>> 8)  | ((n & 0x00FF00FF) << 8);
        n = ((n & 0xFFFF0000) >>> 16) | ((n & 0x0000FFFF) << 16);
        return n;
    }

    /**
     * 请不要认为「方法三」一定就比「方法一」等直接采用循环的方式更快。此类做法的最大作用，不是处理 int，
     * 而是处理更大位数的情况，在长度只有 32 位的 int 的情况下，该做法不一定就比循环要快（该做法会产生多
     * 个的中间结果，导致赋值发生多次，而且由于指令之间存在对 n 数值依赖，可能不会被优化为并行指令），这个
     * 道理和对于排序元素少的情况下，我们会选择「冒泡排序」而不是「归并排序」是一样的，因为「冒泡排序」常数更小。
     */
}
